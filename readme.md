Программа из командной строки запускается так:
$ python2.7
>>> from process import Processor
>>> text = u'офицiанскую'  # например
>>> t, change, w_edits, _json = Processor.process_text(text, show=False, delimiters=[u'', u'{', u'}'], check_brackets=False, print_log=False)
>>> print t
официанскую

---------------------------------------------------------------------------

method Processor.process_text(text, show, delimiters, check_brackets, print_log=True)

Используется для преобразования текста в дореформенной орфографии в современную орфографию.


Parameters: text: unicode
                 Оригинальный текст в дореформенной орфографии
            show: boolean
                 Используется для обозначения того, будут ли в результат включены слова в дореформенной орфографии, которые были заменены. Если параметр check_brackets=True, то замененные слова в любом случае показываются, независимо от значения параметра show.
            delimiters: list из трех элементов типа unicode
                 Используется для обозначения замененных слов. Первый элемент помещается перед новым словом, а вторые два элемента выделяют замененное слово. Например, если delimiters=[u'', u'{', u'}'], а text=u"примеръ", то результат будет "пример{примеръ}". Если delimiters=[u'<choice><reg>', u'</reg><orig>', u'</orig></choice>'], то результат будет "<choice><reg>пример</reg><orig>примеръ</orig></choice>". КОМУ МОЖЕТ ПОТРЕБОВАТЬСЯ ПОСЛЕДНИЙ ВАРИАНТ? ПРО ТАКОЙ ФОРМАТ, ГОВОРИТСЯ, НАПРИМЕР, ВОТ ЗДЕСЬ: https://en.wikipedia.org/wiki/Text_Encoding_Initiative#Choice_tag 

            check_brackets: boolean
                 Используется для обозначения в преобразованном тексте редакторской правки в оригинале текста. Например, если  text=u'Пройдя комнату, такъ [называемую], офиціанскую', delimiters=[u'', u'{', u'}'], check_brackets=True, то результат будет следующим: "Пройдя комнату, так{такъ} <choice original_editorial_correction='[называемую]'><sic></sic><corr>называемую</corr></choice>, официанскую{офицiанскую}"
                ЗДЕСЬ ТОТ ЖЕ ВОПРОС, ЧТО И ВЫШЕ - ЗАЧЕМ МОЖЕТ БЫТЬ НУЖНО ТАКОЕ ФОРМАТИРОВАНИЕ?

            print_log: boolean
                 КАК ОПИСАТЬ, ЧТО ПОКАЗЫВАЕТ ЛОГ? В КАКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ ПРОВЕРЯЕТСЯ НАЛИЧИЕ СПЕЦИАЛЬНЫХ СИМВОЛОВ И В КАКОЙ ОНИ ЗАМЕНЯЮТСЯ?
                 Примеры такие, если print_log=True, а text = u'офицiанскую', то на печать выводится следующее:
ѣ е офицiанскую
чьк чк офицiанскую
ъи ы офицiанскую
чьн чн офицiанскую
ияся иеся офицiанскую
i и официанскую
щию щью официанскую
ѳ ф официанскую
EL официанскую
                 Если text=u'выраженіемъ', то на печать выводится вот это:
ѣ е выраженiем
чьк чк выраженiем
ъи ы выраженiем
чьн чн выраженiем
ияся иеся выраженiем
i и выражением
щию щью выражением
ѳ ф выражением
EL выражением


Returns: text: unicode
              Преобразованный текст
         changes: unicode
              Произведенные изменения в виде "офицiанскую --> официанскую"
         wrong_edits: list
                 ВСЕ ВРЕМЯ ПУСТОЙ СПИСОК, НЕ ЯСНО, ЧТО ТАМ МОЖЕТ БЫТЬ. ПРИМЕРОВ НЕТ
         str_json: str
               Например, если text=u'офицiанскую', то str_json = '{"0": {"type": "word", "old_plain_word": null, "word": u"официанскую", "old_word": u"офицiанскую", "plain_word": null}}'

ЧТО ОЗНАЧАЮТ КЛЮЧИ OLD_PLAIN_WORD И PLAIN_WORD? ВО ВСЕХ ПРИМЕРАХ ЗНАЧЕНИЯ ЭТИХ КЛЮЧЕЙ = NULL. МОЖЕТ БЫТЬ, ЕСЛИ ВЗЯТЬ БОЛЬШЕ ПРИМЕРОВ ТЕКСТА ИЗ ТОГО XML-ФАЙЛА, ЧТО ПРИСЫЛАЛ ДАНИИЛ, ТО МОЖНО НАЙТИ ПРИМЕР, КОГДА ИХ ЗНАЧЕНИЕ НЕ РАВНО NULL, И ТОГДА МОЖНО БЫЛО БЫ ПОНЯТЬ, ЧТО ТАКОЕ OLD_PLAIN_WORD И PLAIN_WORD?  


